struct %main.base_type%*%main.multiply%(struct Stack*restrict output_stack, struct Stack*restrict local_stack, struct %main.base_type%*a, struct %main.base_type%*b#main.has_misc_parameter, struct %misc.base_type%*%main.misc_name%#)
{
    if (!a->coefficient_count && !b->coefficient_count)
    {
        return %main.additive_identity%;
    }
    struct %main.base_type%*out = polynomial_allocate(output_stack, a->coefficient_count + b->coefficient_count - 1);
    for (size_t i = 0; i < out->coefficient_count; ++i)
    {
        out->coefficients[i] = %coefficient.additive_identity%;
    }
    void*local_stack_savepoint = local_stack->cursor;
    for (size_t i = 0; i < a->coefficient_count; ++i)
    {
        for (size_t j = 0; j < b->coefficient_count; ++j)
        {
            out->coefficients[i + j] = %coefficient.add%(output_stack#coefficient.add_takes_two_stacks, local_stack#, out->coefficients[i + j],
                %coefficient.multiply%(local_stack, output_stack, a->coefficients[i], b->coefficients[j]#coefficient.has_misc_parameter, %main.misc_name%#)#coefficient.add_and_subtract_take_misc, %main.misc_name%#);
        }
    }
    %main.base_type_name%_trim_leading_zeroes(out);
    local_stack->cursor = local_stack_savepoint;
    return out;
}